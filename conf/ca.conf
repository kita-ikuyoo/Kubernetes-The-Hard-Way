[req]
distinguished_name = req_distinguished_name
# dont ask interactive questions
prompt = no
# create a self-signed CA 
x509_extensions    = ca_x509_extensions

[ca_x509_extensions]
# basicConstraints determines whether a certificate is a CA certificate.
# This means this certificate can be used to sign other certificates.
basicConstraints = CA:true
# keyCertSign: this key can be used to sign certificates
# cRL(certificate revocation list) is the list of revocated certificates. And this list should also be 
# signed before it is published to prevent adversarial attack.
# So cRLSign means this key can be used to sign CRLs.
keyUsage = keyCertSign, cRLSign


[req_distinguished_name]
# C: country    ST: state   L:locality(city)    CN: common name
# Pay attention here, C can only be two alphabets
C = JP
ST = Kyoto
L = Kyoto
CN = CA


# adminは誰かがAPI serverに接続するときに使われているものです
[admin]
distinguished_name = admin_distinguished_name
prompt = no
# 証明書作り時入れるべきの拡張
# x509_extensionsとの違い：x509_extensionsはCRTを作る時の拡張です
req_extensions = default_req_extensions

[admin_distinguished_name]
CN = admin
# kubernetesではsystem:mastersのグループの主体として扱う
# kubernetesのユーザーグループの管理は証明書のdistinguished_nameのOによって行われます
O = system:masters


[service-accounts]
distinguished_name = service-accounts_distinguished_name
prompt=no
# why does service account only need clientAuth but not serverAuth? The certificate of service account is only used to 
# create JWT token used by other processes to communicate with api server. So, it is just access be others rather than access others
# from themselves.
req_extensions = default_req_extensions

[service-accounts_distinguished_name]
CN = service-accounts

# Worker Nodes
#
# Kubernetes uses a [special-purpose authorization mode](https://kubernetes.io/docs/admin/authorization/node/)
# called Node Authorizer, that specifically authorizes API requests made
# by [Kubelets](https://kubernetes.io/docs/concepts/overview/components/#kubelet).
# In order to be authorized by the Node Authorizer, Kubelets must use a credential
# that identifies them as being in the `system:nodes` group, with a username
# of `system:node:<nodeName>`.

[node-0]
distinguished_name = node-0_distinguished_name
prompt=no
req_extensions = node-0_req_extensions

[node-0_distinguished_name]
C = JP
ST = Kyoto
L = Kyoto
O = system:nodes
CN = system:node:node-0

[node-0_req_extensions]
basicConstraints     =CA:FALSE
extendedKeyUsage     =clientAuth, serverAuth
keyUsage             =critical, digitalSignature, keyEncipherment
subjectKeyIdentifier =hash
nsCertType           = client
nsComment            = "Node-0 Certificate"
# subjectAltName(SAN) は　一つの主体の別名です。CNの補足みたいな物です。
subjectAltName       = IP:192.168.119.135, DNS:node-0

[node-1]
distinguished_name = node-1_distinguished_name
prompt=no
req_extensions = node-1_req_extensions

[node-1_distinguished_name]
C = JP
ST = Kyoto
L = Kyoto
O = system:nodes
CN = system:node:node-1

[node-1_req_extensions]
basicConstraints     =CA:FALSE
extendedKeyUsage     =clientAuth, serverAuth
keyUsage             =critical, digitalSignature, keyEncipherment
subjectKeyIdentifier =hash
nsCertType           = client
nsComment            = "Node-1 Certificate"
# subjectAltName(SAN) は　一つの主体の別名です。CNの補足みたいな物です。
subjectAltName       = IP:192.168.119.136, DNS:node-1

[kube-proxy]
distinguished_name = kube-proxy_distinguished_name
prompt = no
req_extensions = kube-proxy_req_extensions

[kube-proxy_distinguished_name]
C = JP
ST = Kyoto
L = Kyoto
O = system:node-proxier
CN = system:kube-proxy

[kube-proxy_req_extensions]
basicConstraints     =CA:FALSE
# clientAuth：kube-proxyはAPI　serverに接続してserviceなどのネットワーク情報知る必要があります
# serverAuth: kube-proxyはヘルス情報とメトリクス情報などをPrometheusなどの監視ツールに提供するため、いくつかのポートを公開しています。
# これらのポートへのアクセスもセキュリティを上げるために、HTTPSを使う場合があります。それで、ここでserverAuthも追加しました。
extendedKeyUsage     = clientAuth, serverAuth
keyUsage             = critical, digitalSignature, keyEncipherment
subjectKeyIdentifier = hash
nsCertType           = client
nsComment            = "Kube Proxy Certificate"
# subjectAltName(SAN) は　一つの主体の別名です。CNの補足みたいな物です。
# 127.0.0.1は同じノードのプロセスからの接続のためです。監視ツールなどは普通違うノードで稼働します。
subjectAltName       = IP:127.0.0.1, DNS:kube-proxy

[kube-controller-manager]
distinguished_name = kube-controller-manager_distinguished_name
prompt = no
req_extensions = kube-controller-manager_req_extensions

[kube-controller-manager_distinguished_name]
C = JP 
ST = Kyoto
L = Kyoto
O = system:kube-controller-manager
CN = system:kube-controller-manager

[kube-controller-manager_req_extensions]
basicConstraints     = CA:FALSE
# kube-proxyと同じく、ヘルス情報とメトリクス情報などをPrometheusなどの監視ツールに提供するため、いくつかのポートを公開しています。
extendedKeyUsage     = clientAuth, serverAuth
keyUsage             = critical, digitalSignature, keyEncipherment
# 127.0.0.1は普通API serverなど同じノードにあるプロセスからの接続のためで、監視ツールは普通他のノードで稼働します。
subjectAltName       = DNS: kube-controller-manager, IP: 127.0.0.1
nsCertType           = client
nsComment            = "Kube-controller-manager Certificate"
subjectKeyIdentifier = hash

[kube-scheduler]
distinguished_name = kube-scheduler_distinguished_name
prompt = no
req_extensions = kube-scheduler_req_extensions

[kube-scheduler_distinguished_name]
C   = JP
ST  = Kyoto
L   = Kyoto
O   = system:kube-scheduler
CN  = system:kube-scheduler

[kube-scheduler_req_extensions]
basicConstraints     = CA:FALSE
extendedKeyUsage     = clientAuth, serverAuth
keyUsage             = critical, digitalSignature, keyEncipherment
subjectAltName       = IP: 127.0.0.1, DNS: kube-scheduler
subjectKeyIdentifier = hash
nsCertType           = client
nsComment            = "Kube Scheduler Certificate"


# API Server
#
# The Kubernetes API server is automatically assigned the `kubernetes`
# internal dns name, which will be linked to the first IP address (`10.32.0.1`)
# from the address range (`10.32.0.0/24`) reserved for internal cluster
# services.

[kube-api-server]
distinguished_name = kube-api-server_distinguished_name
prompt             = no
req_extensions     = kube-api-server_req_extensions

[kube-api-server_distinguished_name]
C = JP
ST = Kyoto
L = Kyoto
CN = kubernetes

[kube-api-server_req_extensions]
basicConstraints     = CA:FALSE
extendedKeyUsage     = clientAuth, serverAuth
keyUsage             = critical, digitalSignature, keyEncipherment
nsCertType           = client, server
nsComment            = "Kube API Server Certificate"
subjectAltName       = @kube-api-server_alt_names
subjectKeyIdentifier = hash

[kube-api-server_alt_names]
IP.0  = 127.0.0.1
IP.1  = 10.32.0.1
# ここのkubernetesはserviceの名前
# kubernetesという名前のserviceは全てのクラスタにデフォルトに作られます
# ここのdefaultはnamespace名。クラスタにはdefaultという名前のnamespaceが最初から存在します。
DNS.0 = kubernetes
DNS.1 = kubernetes.default
# svc:これはserviceの名前解決という標識
DNS.2 = kubernetes.default.svc
DNS.3 = kubernetes.default.svc.cluster
DNS.4 = kubernetes.svc.cluster.local
# 
DNS.5 = server.kubernetes.local
DNS.6 = api-server.kubernetes.local






[default_req_extensions]
basicConstraints     = CA:FALSE
# keyusage: 暗号学的に何に使う　extendedkeyusage: 証明書の目的
# 証明書に署名できるとしても、サーバーとクライアント両方に使うべきではありません
extendedKeyUsage     = clientAuth
# keyEncipherment: 鍵の暗号化に使えます。　例えば、共通鍵暗号を作るためにプレマスタシークレットを暗号化して相手に送る時
# 共通鍵は公開鍵方式より速度が早い
keyUsage             = critical, digitalSignature, keyEncipherment
# 従来の使い方、現在はextendedKeyUsageの方が標準になっています。互換性のためにnsCertTypeを入れています。
nsCertType           = client
# commentだけ
nsComment            = "Admin Client Certificate"
# この証明書に入る公開鍵のIDをhash方式で作る。このIDha証明書チェーンの管理や参照に使われます。

subjectKeyIdentifier = hash